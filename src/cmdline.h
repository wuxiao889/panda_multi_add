/** @file cmdline.h
 *  @brief The header file for the command line option parser
 *  generated by GNU Gengetopt version 2.23
 *  http://www.gnu.org/software/gengetopt.
 *  DO NOT modify this file, since it can be overwritten
 *  @author GNU Gengetopt */

#ifndef CMDLINE_H
#define CMDLINE_H

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h> /* for FILE */

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#ifndef CMDLINE_PARSER_PACKAGE
/** @brief the program name (used for printing errors) */
#define CMDLINE_PARSER_PACKAGE "pandaPIengine"
#endif

#ifndef CMDLINE_PARSER_PACKAGE_NAME
/** @brief the complete program name (used for help and version) */
#define CMDLINE_PARSER_PACKAGE_NAME "pandaPIengine"
#endif

#ifndef CMDLINE_PARSER_VERSION
/** @brief the program version */
#define CMDLINE_PARSER_VERSION "0.1"
#endif

/** @brief Where the command line options are stored */
struct gengetopt_args_info {
  const char *help_help; /**< @brief Print help and exit help description.  */
  const char
      *version_help; /**< @brief Print version and exit help description.  */
  const char *debug_help; /**< @brief activate debug mode help description.  */
  int seed_arg;    /**< @brief specify the random seed (default='42').  */
  char *seed_orig; /**< @brief specify the random seed original value given at
                      command line.  */
  const char
      *seed_help;    /**< @brief specify the random seed help description.  */
  int timelimit_arg; /**< @brief specify timelimit in seconds (default='1800').
                      */
  char *timelimit_orig; /**< @brief specify timelimit in seconds original value
                           given at command line.  */
  const char *timelimit_help; /**< @brief specify timelimit in seconds help
                                 description.  */
  int noPlanOutput_flag; /**< @brief don't output the plan [default=print plan]
                            (default=off).  */
  const char *noPlanOutput_help; /**< @brief don't output the plan
                                    [default=print plan] help description.  */
  int writeInputToHDDL_flag; /**< @brief don't run the engine at all. Output the
                                given SAS+ planning problem as HDDL again.
                                (default=off).  */
  const char *writeInputToHDDL_help; /**< @brief don't run the engine at all.
                                        Output the given SAS+ planning problem
                                        as HDDL again. help description.  */
  int heuristicHelp_flag;         /**< @brief will print the help page for the
                                     heuristics (default=off).  */
  const char *heuristicHelp_help; /**< @brief will print the help page for the
                                     heuristics help description.  */
  const char
      *progression_help; /**< @brief progression search help description.  */
  const char *sat_help;  /**< @brief translation to SAT help description.  */
  const char *bdd_help;  /**< @brief symbolic search help description.  */
  const char *translation_help; /**< @brief translation-based planner help
                                   description.  */
  const char
      *interactive_help; /**< @brief interactive search help description.  */
  char **heuristic_arg;  /**< @brief specify heuristics. If you want to know how
                            to specify a heuristic, use --heuristicHelp. The
                            first heuristic in the list is the one used for
                            search. Starting from the second, all other
                            heuristics are used as tie-breakers. If you specify
                            the same heuristic twice, it will only be computed
                            once. If all tie-breakers are equal, a random number
                            selected per search node is used as the final
                            tie-breaker. (default='rc2(ff)').  */
  char *
      *heuristic_orig; /**< @brief specify heuristics. If you want to know how
                          to specify a heuristic, use --heuristicHelp. The first
                          heuristic in the list is the one used for search.
                          Starting from the second, all other heuristics are
                          used as tie-breakers. If you specify the same
                          heuristic twice, it will only be computed once. If all
                          tie-breakers are equal, a random number selected per
                          search node is used as the final tie-breaker. original
                          value given at command line.  */
  unsigned int
      heuristic_min; /**< @brief specify heuristics. If you want to know how to
                        specify a heuristic, use --heuristicHelp. The first
                        heuristic in the list is the one used for search.
                        Starting from the second, all other heuristics are used
                        as tie-breakers. If you specify the same heuristic
                        twice, it will only be computed once. If all
                        tie-breakers are equal, a random number selected per
                        search node is used as the final tie-breaker.'s minimum
                        occurreces */
  unsigned int
      heuristic_max; /**< @brief specify heuristics. If you want to know how to
                        specify a heuristic, use --heuristicHelp. The first
                        heuristic in the list is the one used for search.
                        Starting from the second, all other heuristics are used
                        as tie-breakers. If you specify the same heuristic
                        twice, it will only be computed once. If all
                        tie-breakers are equal, a random number selected per
                        search node is used as the final tie-breaker.'s maximum
                        occurreces */
  const char
      *heuristic_help; /**< @brief specify heuristics. If you want to know how
                          to specify a heuristic, use --heuristicHelp. The first
                          heuristic in the list is the one used for search.
                          Starting from the second, all other heuristics are
                          used as tie-breakers. If you specify the same
                          heuristic twice, it will only be computed once. If all
                          tie-breakers are equal, a random number selected per
                          search node is used as the final tie-breaker. help
                          description.  */
  int astarweight_arg; /**< @brief weight of the heuristic for weighted A* (also
                          called greedy-A*). The default is 1, which yields the
                          standard A* algorithm. (default='1').  */
  char *astarweight_orig; /**< @brief weight of the heuristic for weighted A*
                             (also called greedy-A*). The default is 1, which
                             yields the standard A* algorithm. original value
                             given at command line.  */
  const char *astarweight_help; /**< @brief weight of the heuristic for weighted
                                   A* (also called greedy-A*). The default is 1,
                                   which yields the standard A* algorithm. help
                                   description.  */
  char *gValue_arg;             /**< @brief g value. You can select
          path: one for each applied action and performed decomposition
          mixed: summed cost of the applied actions plus 1 for every applied decomposition
          action: summed cost of the applied actions
          none: constant zero.
         (default='path').  */
  char *gValue_orig;            /**< @brief g value. You can select
          path: one for each applied action and performed decomposition
          mixed: summed cost of the applied actions plus 1 for every applied decomposition
          action: summed cost of the applied actions
          none: constant zero.
         original value given at command line.  */
  const char *gValue_help;      /**< @brief g value. You can select
       path: one for each applied action and performed decomposition
       mixed: summed cost of the applied actions plus 1 for every applied
      decomposition      action: summed cost of the applied actions      none: constant zero.
      help description.  */
  int suboptimal_flag; /**< @brief suboptimal search (early goal test and
                          visited lists ignores costs) (default=off).  */
  const char
      *suboptimal_help;   /**< @brief suboptimal search (early goal test and
                             visited lists ignores costs) help description.  */
  int noVisitedList_flag; /**< @brief disable visited lists [default=with lists]
                             (default=off).  */
  const char *noVisitedList_help; /**< @brief disable visited lists
                                     [default=with lists] help description.  */
  int noTaskHash_flag; /**< @brief disable task hashing [default=with task hash]
                          (default=on).  */
  const char *noTaskHash_help; /**< @brief disable task hashing [default=with
                                  task hash] help description.  */
  int noTaskSequenceHash_flag; /**< @brief disable task sequence hashing
                                  [default=with task sequence hash]
                                  (default=on).  */
  const char *noTaskSequenceHash_help; /**< @brief disable task sequence hashing
                                          [default=with task sequence hash] help
                                          description.  */
  int noTopologicalOrdering_flag; /**< @brief disable visited checking with task
                                     sequences, this makes totally-ordered
                                     visited lists incomplete [default=with
                                     order] (default=on).  */
  const char
      *noTopologicalOrdering_help; /**< @brief disable visited checking with
                                      task sequences, this makes totally-ordered
                                      visited lists incomplete [default=with
                                      order] help description.  */
  int noLayers_flag; /**< @brief disable layer hashing [default=with layer hash]
                        (default=on).  */
  const char *noLayers_help; /**< @brief disable layer hashing [default=with
                                layer hash] help description.  */
  int noOrderPairs_flag; /**< @brief disable order pairs hashing [default=with
                            order pairs hash] (default=on).  */
  const char
      *noOrderPairs_help; /**< @brief disable order pairs hashing [default=with
                             order pairs hash] help description.  */
  int noParallelSequences_flag; /**< @brief disable optimisation for parallel
                                   sequences [default=with optimisation]
                                   (default=on).  */
  const char *noParallelSequences_help; /**< @brief disable optimisation for
                                           parallel sequences [default=with
                                           optimisation] help description.  */
  int noGIcheck_flag; /**< @brief disable GI-complete equivalence checking for
                         partially ordered task networks [default=with
                         GI-complete checking] (default=on).  */
  const char
      *noGIcheck_help; /**< @brief disable GI-complete equivalence checking for
                          partially ordered task networks [default=with
                          GI-complete checking] help description.  */
  int blockcompression_flag; /**< @brief apply block compression (default=on).
                              */
  const char *blockcompression_help; /**< @brief apply block compression help
                                        description.  */
  int satmutexes_flag; /**< @brief encode SAT mutexes (default=on).  */
  const char
      *satmutexes_help; /**< @brief encode SAT mutexes help description.  */
  char *pruning_arg;    /**< @brief pruning mode (default='ff').  */
  char *pruning_orig;   /**< @brief pruning mode original value given at command
                           line.  */
  const char *pruning_help; /**< @brief pruning mode help description.  */
  int methodPreconditionsInSeparateLeafs_flag; /**< @brief if in partial order
                                                  mode, put method precondition
                                                  actions into extra leafs. This
                                                  allows for better encoding of
                                                  executability, but may
                                                  increase the size of the PDT
                                                  (default=off).  */
  const char
      *methodPreconditionsInSeparateLeafs_help; /**< @brief if in partial order
                                                   mode, put method precondition
                                                   actions into extra leafs.
                                                   This allows for better
                                                   encoding of executability,
                                                   but may increase the size of
                                                   the PDT help description.  */
  int optimisation_flag; /**< @brief after finding the first plan, continue
                            search to find plans of lower cost (default=on).  */
  const char *optimisation_help; /**< @brief after finding the first plan,
                                    continue search to find plans of lower cost
                                    help description.  */
  char *downward_arg;            /**< @brief path to fast downward executable
                                    (default='none').  */
  char *downward_orig; /**< @brief path to fast downward executable original
                          value given at command line.  */
  const char *downward_help; /**< @brief path to fast downward executable help
                                description.  */
  char *downwardConf_arg; /**< @brief configuration given to fast downward. This
                             has two special values that are expanded to proper
                             configurations. Use ehc-ff() for enforced hill
                             climbing with FF and lazy-cea() for lazy-greedy
                             search with the context enhanced additive
                             heuristic. (default='ehc-ff()').  */
  char *
      downwardConf_orig; /**< @brief configuration given to fast downward. This
                            has two special values that are expanded to proper
                            configurations. Use ehc-ff() for enforced hill
                            climbing with FF and lazy-cea() for lazy-greedy
                            search with the context enhanced additive heuristic.
                            original value given at command line.  */
  const char
      *downwardConf_help; /**< @brief configuration given to fast downward. This
                             has two special values that are expanded to proper
                             configurations. Use ehc-ff() for enforced hill
                             climbing with FF and lazy-cea() for lazy-greedy
                             search with the context enhanced additive
                             heuristic. help description.  */
  char *transtype_arg;  /**< @brief type of translation to use (default='push').
                         */
  char *transtype_orig; /**< @brief type of translation to use original value
                           given at command line.  */
  const char *transtype_help; /**< @brief type of translation to use help
                                 description.  */
  int forceTransType_flag; /**< @brief by default, pandaPIengine will switch to
                              a getter encoding if it detects the prerequisites
                              for it in the problem. This flag disables this
                              behaviour and always uses the given encoding.
                              (default=off).  */
  const char
      *forceTransType_help; /**< @brief by default, pandaPIengine will switch to
                               a getter encoding if it detects the prerequisites
                               for it in the problem. This flag disables this
                               behaviour and always uses the given encoding.
                               help description.  */
  char *sasfile_arg;  /**< @brief name of the SAS+ file generated. In planning
                         mode this file will be written and used as a temporary
                         file (default='output.sas').  */
  char *sasfile_orig; /**< @brief name of the SAS+ file generated. In planning
                         mode this file will be written and used as a temporary
                         file original value given at command line.  */
  const char *sasfile_help; /**< @brief name of the SAS+ file generated. In
                               planning mode this file will be written and used
                               as a temporary file help description.  */
  int pgb_arg; /**< @brief the initial value of the progression bound. If zero,
                  the minimum progression bound will be computed and used
                  instead. This is the default behaviour! (default='0').  */
  char *pgb_orig; /**< @brief the initial value of the progression bound. If
                     zero, the minimum progression bound will be computed and
                     used instead. This is the default behaviour! original value
                     given at command line.  */
  const char *
      pgb_help; /**< @brief the initial value of the progression bound. If zero,
                   the minimum progression bound will be computed and used
                   instead. This is the default behaviour! help description.  */
  int pgbsteps_arg;    /**< @brief step size of the progression bound
                          (default='1').  */
  char *pgbsteps_orig; /**< @brief step size of the progression bound original
                          value given at command line.  */
  const char *pgbsteps_help; /**< @brief step size of the progression bound help
                                description.  */
  int onlyGenerate_flag;     /**< @brief only generate the translation and don't
                                solv it. This overrides also iterate (default=off).
                              */
  const char *onlyGenerate_help; /**< @brief only generate the translation and
                                    don't solv it. This overrides also iterate
                                    help description.  */
  int iterate_flag; /**< @brief if the initial pgb is unsolvable, increase by
                       one and continue (default=off).  */
  const char
      *iterate_help;  /**< @brief if the initial pgb is unsolvable, increase by
                         one and continue help description.  */
  int realCosts_flag; /**< @brief if enabled use the actual cost in the encoded
                         model. Default is off, then all operators have unit
                         cost. (default=off).  */
  const char *realCosts_help; /**< @brief if enabled use the actual cost in the
                                 encoded model. Default is off, then all
                                 operators have unit cost. help description.  */

  unsigned int help_given;      /**< @brief Whether help was given.  */
  unsigned int version_given;   /**< @brief Whether version was given.  */
  unsigned int debug_given;     /**< @brief Whether debug was given.  */
  unsigned int seed_given;      /**< @brief Whether seed was given.  */
  unsigned int timelimit_given; /**< @brief Whether timelimit was given.  */
  unsigned int
      noPlanOutput_given; /**< @brief Whether noPlanOutput was given.  */
  unsigned int writeInputToHDDL_given; /**< @brief Whether writeInputToHDDL was
                                          given.  */
  unsigned int
      heuristicHelp_given; /**< @brief Whether heuristicHelp was given.  */
  unsigned int progression_given; /**< @brief Whether progression was given.  */
  unsigned int sat_given;         /**< @brief Whether sat was given.  */
  unsigned int bdd_given;         /**< @brief Whether bdd was given.  */
  unsigned int translation_given; /**< @brief Whether translation was given.  */
  unsigned int interactive_given; /**< @brief Whether interactive was given.  */
  unsigned int heuristic_given;   /**< @brief Whether heuristic was given.  */
  unsigned int astarweight_given; /**< @brief Whether astarweight was given.  */
  unsigned int gValue_given;      /**< @brief Whether gValue was given.  */
  unsigned int suboptimal_given;  /**< @brief Whether suboptimal was given.  */
  unsigned int
      noVisitedList_given; /**< @brief Whether noVisitedList was given.  */
  unsigned int noTaskHash_given; /**< @brief Whether noTaskHash was given.  */
  unsigned int noTaskSequenceHash_given; /**< @brief Whether noTaskSequenceHash
                                            was given.  */
  unsigned int
      noTopologicalOrdering_given; /**< @brief Whether noTopologicalOrdering was
                                      given.  */
  unsigned int noLayers_given;     /**< @brief Whether noLayers was given.  */
  unsigned int
      noOrderPairs_given; /**< @brief Whether noOrderPairs was given.  */
  unsigned int noParallelSequences_given; /**< @brief Whether
                                             noParallelSequences was given.  */
  unsigned int noGIcheck_given; /**< @brief Whether noGIcheck was given.  */
  unsigned int blockcompression_given; /**< @brief Whether blockcompression was
                                          given.  */
  unsigned int satmutexes_given; /**< @brief Whether satmutexes was given.  */
  unsigned int pruning_given;    /**< @brief Whether pruning was given.  */
  unsigned int methodPreconditionsInSeparateLeafs_given; /**< @brief Whether
                                                            methodPreconditionsInSeparateLeafs
                                                            was given.  */
  unsigned int
      optimisation_given;      /**< @brief Whether optimisation was given.  */
  unsigned int downward_given; /**< @brief Whether downward was given.  */
  unsigned int
      downwardConf_given;       /**< @brief Whether downwardConf was given.  */
  unsigned int transtype_given; /**< @brief Whether transtype was given.  */
  unsigned int
      forceTransType_given;    /**< @brief Whether forceTransType was given.  */
  unsigned int sasfile_given;  /**< @brief Whether sasfile was given.  */
  unsigned int pgb_given;      /**< @brief Whether pgb was given.  */
  unsigned int pgbsteps_given; /**< @brief Whether pgbsteps was given.  */
  unsigned int
      onlyGenerate_given;       /**< @brief Whether onlyGenerate was given.  */
  unsigned int iterate_given;   /**< @brief Whether iterate was given.  */
  unsigned int realCosts_given; /**< @brief Whether realCosts was given.  */

  char **inputs;       /**< @brief unnamed options (options without names) */
  unsigned inputs_num; /**< @brief unnamed options number */
  int planningAlgorithm_group_counter; /**< @brief Counter for group
                                          planningAlgorithm */
};

/** @brief The additional parameters to pass to parser functions */
struct cmdline_parser_params {
  int override; /**< @brief whether to override possibly already present options
                   (default 0) */
  int initialize;      /**< @brief whether to initialize the option structure
                          gengetopt_args_info (default 1) */
  int check_required;  /**< @brief whether to check that all required options
                          were provided (default 1) */
  int check_ambiguity; /**< @brief whether to check for options already
                          specified in the option structure gengetopt_args_info
                          (default 0) */
  int print_errors;    /**< @brief whether getopt_long should print an error
                          message for a bad option (default 1) */
};

/** @brief the purpose string of the program */
extern const char *gengetopt_args_info_purpose;
/** @brief the usage string of the program */
extern const char *gengetopt_args_info_usage;
/** @brief the description string of the program */
extern const char *gengetopt_args_info_description;
/** @brief all the lines making the help output */
extern const char *gengetopt_args_info_help[];

/**
 * The command line parser
 * @param argc the number of command line options
 * @param argv the command line options
 * @param args_info the structure where option information will be stored
 * @return 0 if everything went fine, NON 0 if an error took place
 */
int cmdline_parser(int argc, char **argv,
                   struct gengetopt_args_info *args_info);

/**
 * The command line parser (version with additional parameters - deprecated)
 * @param argc the number of command line options
 * @param argv the command line options
 * @param args_info the structure where option information will be stored
 * @param override whether to override possibly already present options
 * @param initialize whether to initialize the option structure my_args_info
 * @param check_required whether to check that all required options were
 * provided
 * @return 0 if everything went fine, NON 0 if an error took place
 * @deprecated use cmdline_parser_ext() instead
 */
int cmdline_parser2(int argc, char **argv,
                    struct gengetopt_args_info *args_info, int override,
                    int initialize, int check_required);

/**
 * The command line parser (version with additional parameters)
 * @param argc the number of command line options
 * @param argv the command line options
 * @param args_info the structure where option information will be stored
 * @param params additional parameters for the parser
 * @return 0 if everything went fine, NON 0 if an error took place
 */
int cmdline_parser_ext(int argc, char **argv,
                       struct gengetopt_args_info *args_info,
                       struct cmdline_parser_params *params);

/**
 * Save the contents of the option struct into an already open FILE stream.
 * @param outfile the stream where to dump options
 * @param args_info the option struct to dump
 * @return 0 if everything went fine, NON 0 if an error took place
 */
int cmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info);

/**
 * Save the contents of the option struct into a (text) file.
 * This file can be read by the config file parser (if generated by gengetopt)
 * @param filename the file where to save
 * @param args_info the option struct to save
 * @return 0 if everything went fine, NON 0 if an error took place
 */
int cmdline_parser_file_save(const char *filename,
                             struct gengetopt_args_info *args_info);

/**
 * Print the help
 */
void cmdline_parser_print_help(void);
/**
 * Print the version
 */
void cmdline_parser_print_version(void);

/**
 * Initializes all the fields a cmdline_parser_params structure
 * to their default values
 * @param params the structure to initialize
 */
void cmdline_parser_params_init(struct cmdline_parser_params *params);

/**
 * Allocates dynamically a cmdline_parser_params structure and initializes
 * all its fields to their default values
 * @return the created and initialized cmdline_parser_params structure
 */
struct cmdline_parser_params *cmdline_parser_params_create(void);

/**
 * Initializes the passed gengetopt_args_info structure's fields
 * (also set default values for options that have a default)
 * @param args_info the structure to initialize
 */
void cmdline_parser_init(struct gengetopt_args_info *args_info);
/**
 * Deallocates the string fields of the gengetopt_args_info structure
 * (but does not deallocate the structure itself)
 * @param args_info the structure to deallocate
 */
void cmdline_parser_free(struct gengetopt_args_info *args_info);

/**
 * The string parser (interprets the passed string as a command line)
 * @param cmdline the command line stirng
 * @param args_info the structure where option information will be stored
 * @param prog_name the name of the program that will be used to print
 *   possible errors
 * @return 0 if everything went fine, NON 0 if an error took place
 */
int cmdline_parser_string(const char *cmdline,
                          struct gengetopt_args_info *args_info,
                          const char *prog_name);
/**
 * The string parser (version with additional parameters - deprecated)
 * @param cmdline the command line stirng
 * @param args_info the structure where option information will be stored
 * @param prog_name the name of the program that will be used to print
 *   possible errors
 * @param override whether to override possibly already present options
 * @param initialize whether to initialize the option structure my_args_info
 * @param check_required whether to check that all required options were
 * provided
 * @return 0 if everything went fine, NON 0 if an error took place
 * @deprecated use cmdline_parser_string_ext() instead
 */
int cmdline_parser_string2(const char *cmdline,
                           struct gengetopt_args_info *args_info,
                           const char *prog_name, int override, int initialize,
                           int check_required);
/**
 * The string parser (version with additional parameters)
 * @param cmdline the command line stirng
 * @param args_info the structure where option information will be stored
 * @param prog_name the name of the program that will be used to print
 *   possible errors
 * @param params additional parameters for the parser
 * @return 0 if everything went fine, NON 0 if an error took place
 */
int cmdline_parser_string_ext(const char *cmdline,
                              struct gengetopt_args_info *args_info,
                              const char *prog_name,
                              struct cmdline_parser_params *params);

/**
 * Checks that all the required options were specified
 * @param args_info the structure to check
 * @param prog_name the name of the program that will be used to print
 *   possible errors
 * @return
 */
int cmdline_parser_required(struct gengetopt_args_info *args_info,
                            const char *prog_name);

extern const char
    *cmdline_parser_gValue_values[]; /**< @brief Possible values for gValue. */
extern const char *
    cmdline_parser_pruning_values[]; /**< @brief Possible values for pruning. */
extern const char
    *cmdline_parser_transtype_values[]; /**< @brief Possible values for
                                           transtype. */

#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* CMDLINE_H */
